<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Obsidian Canvas ‚Üí HTML ËΩ¨Êç¢Âô®</title>
    <!-- Ê∑ªÂä† marked.js Áî®‰∫é Markdown Ê∏≤Êüì -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: #0d0d0d;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        #app {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        #sidebar {
            width: 60px;
            background: #1a1a1a;
            border-right: 1px solid #2a2a2a;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 0;
            gap: 20px;
            flex-shrink: 0;
        }

        .sidebar-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: #2a2a2a;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 20px;
            position: relative;
        }

        .sidebar-icon:hover {
            background: #3a3a3a;
            transform: scale(1.1);
        }

        .sidebar-icon input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            top: 0;
            left: 0;
        }

        .sidebar-icon .badge {
            position: absolute;
            top: -4px;
            right: -4px;
            background: #ef4444;
            color: white;
            font-size: 10px;
            font-weight: bold;
            padding: 2px 5px;
            border-radius: 10px;
            min-width: 16px;
            text-align: center;
        }

        .sidebar-divider {
            width: 30px;
            height: 1px;
            background: #2a2a2a;
        }

        .sidebar-bottom {
            margin-top: auto;
        }

        #main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0d0d0d;
            overflow: hidden;
        }

        #toolbar {
            height: 50px;
            background: #1a1a1a;
            border-bottom: 1px solid #2a2a2a;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
            flex-shrink: 0;
            z-index: 100;
        }

        .toolbar-btn {
            padding: 8px 16px;
            background: #2a2a2a;
            border: none;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .toolbar-btn:hover {
            background: #3a3a3a;
        }

        .toolbar-btn.primary {
            background: #7c3aed;
        }

        .toolbar-btn.primary:hover {
            background: #6d28d9;
        }

        .toolbar-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .toolbar-divider {
            width: 1px;
            height: 24px;
            background: #2a2a2a;
        }

        .toolbar-info {
            margin-left: auto;
            font-size: 12px;
            color: #888;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        #canvas-workspace {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #0d0d0d;
        }

        #canvas-viewport {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            cursor: default;
        }

        #canvas-viewport.space-mode {
            cursor: grab;
        }

        #canvas-viewport.dragging {
            cursor: grabbing;
        }

        .grid-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
        }

        #canvas-content {
            position: absolute;
            transform-origin: 0 0;
            will-change: transform;
        }

        #zoom-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #333;
            color: #fff;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            font-family: monospace;
            pointer-events: none;
            z-index: 1000;
        }

        #shortcuts-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #333;
            color: #888;
            padding: 12px;
            border-radius: 6px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            line-height: 1.6;
        }

        .shortcut-line {
            display: flex;
            gap: 10px;
        }

        .shortcut-key {
            color: #7c3aed;
            font-family: monospace;
        }

        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #444;
            pointer-events: none;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        .empty-state-text {
            font-size: 16px;
            margin-bottom: 8px;
        }

        .empty-state-hint {
            font-size: 12px;
            color: #333;
        }

        /* Canvas ËäÇÁÇπ */
        .canvas-node {
            position: absolute;
            background: rgba(45, 45, 45, 0.15);
            border: 1px solid rgba(70, 70, 70, 0.3);
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            cursor: default;
            font-size: 13px;
            line-height: 1.5;
            overflow: auto;
        }

        .canvas-node:hover {
            box-shadow: 0 4px 12px rgba(124,58,237,0.3);
        }

        .shape-predefined-process {
            border-left-width: 4px;
            border-right-width: 4px;
        }

        .shape-document {
            border-bottom: 3px solid currentColor;
            border-radius: 4px;
        }

        .shape-ellipse {
            border-radius: 50%;
        }

        .text-align-left { text-align: left; }
        .text-align-center { text-align: center; }
        .text-align-right { text-align: right; }

        .border-invisible {
            border: none !important;
            background: transparent !important;
        }

        /* È¢úËâ≤Á±ª */
        .color-1 { background: rgba(208, 115, 115, 0.08); border-color: rgba(208, 115, 115, 0.2); color: rgba(208, 115, 115, 1); }
        .color-2 { background: rgba(230, 150, 80, 0.08); border-color: rgba(230, 150, 80, 0.2); color: rgba(230, 150, 80, 1); }
        .color-3 { background: rgba(208, 180, 75, 0.08); border-color: rgba(208, 180, 75, 0.2); color: rgba(208, 180, 75, 1); }
        .color-4 { background: rgba(100, 180, 90, 0.08); border-color: rgba(100, 180, 90, 0.2); color: rgba(100, 180, 90, 1); }
        .color-5 { background: rgba(100, 140, 200, 0.08); border-color: rgba(100, 140, 200, 0.2); color: rgba(100, 140, 200, 1); }
        .color-6 { background: rgba(150, 100, 200, 0.08); border-color: rgba(150, 100, 200, 0.2); color: rgba(150, 100, 200, 1); }

        .canvas-node.text {
            color: #e0e0e0;
            user-select: text;
            white-space: pre-wrap;        /* ‰øùÁïôÁ©∫ÁôΩÂíåÊç¢Ë°å */
            word-wrap: break-word;        /* Ëá™Âä®Êç¢Ë°å */
            word-break: break-word;       /* ÂçïËØçËá™Âä®Êç¢Ë°å */
            overflow-wrap: break-word;    /* Ê∫¢Âá∫Êç¢Ë°å */
        }

        /* Markdown Ê†∑Âºè */
        .canvas-node.text h1, .canvas-node.text h2, .canvas-node.text h3,
        .canvas-node.text h4, .canvas-node.text h5, .canvas-node.text h6 {
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .canvas-node.text h1 { font-size: 1.8em; }
        .canvas-node.text h2 { font-size: 1.5em; }
        .canvas-node.text h3 { font-size: 1.3em; }
        .canvas-node.text h4 { font-size: 1.1em; }
        .canvas-node.text h5 { font-size: 1em; }
        .canvas-node.text h6 { font-size: 0.9em; }

        .canvas-node.text p {
            margin: 0.5em 0;
        }

        .canvas-node.text ul, .canvas-node.text ol {
            margin-left: 1.5em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }

        .canvas-node.text li {
            margin: 0.3em 0;
        }

        .canvas-node.text code {
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .canvas-node.text pre {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 0.5em 0;
        }

        .canvas-node.text pre code {
            background: none;
            padding: 0;
        }

        .canvas-node.text blockquote {
            border-left: 3px solid #7c3aed;
            padding-left: 1em;
            margin: 0.5em 0;
            color: #aaa;
        }

        .canvas-node.text a {
            color: #7c3aed;
            text-decoration: none;
        }

        .canvas-node.text a:hover {
            text-decoration: underline;
        }

        .canvas-node.text strong {
            font-weight: 600;
        }

        .canvas-node.text em {
            font-style: italic;
        }

        .canvas-node.text hr {
            border: none;
            border-top: 1px solid rgba(255,255,255,0.1);
            margin: 1em 0;
        }

        .canvas-node.file {
            background: rgba(26, 26, 26, 0.15);
            border: 2px solid rgba(70, 70, 70, 0.3);
            padding: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .canvas-node.image {
            padding: 0;
            overflow: hidden;
            background: rgba(26, 26, 26, 0.15);
            border: 2px solid rgba(70, 70, 70, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .canvas-node.image img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
        }

        .canvas-node.image.missing-image {
            background: rgba(45, 45, 45, 0.15);
            flex-direction: column;
            gap: 8px;
            padding: 12px;
        }

        .missing-image-icon {
            font-size: 24px;
            opacity: 0.5;
        }

        .missing-image-text {
            font-size: 10px;
            color: #888;
            text-align: center;
        }

        .canvas-node.group {
            background: rgba(45, 45, 45, 0.05);
            border: 2px solid rgba(85, 85, 85, 0.3);
            padding: 0;
            z-index: -1;
        }

        .group-label {
            position: absolute;
            top: 8px;
            left: 12px;
            background: rgba(45, 45, 45, 0.8);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            color: #bbb;
        }

        .file-name {
            color: #7c3aed;
            font-size: 12px;
            text-align: center;
        }

        .canvas-svg {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 0;
        }

        .edge-line {
            fill: none;
            stroke-width: 2;
        }

        #folder-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        #folder-modal.show {
            display: flex;
        }

        .modal-content {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            text-align: center;
        }

        .modal-icon {
            font-size: 64px;
            opacity: 0.3;
        }

        .modal-title {
            font-size: 24px;
            font-weight: 600;
        }

        .modal-text {
            font-size: 14px;
            color: #888;
            line-height: 1.6;
        }

        .folder-input-btn {
            padding: 12px 24px;
            background: #7c3aed;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-block;
            position: relative;
        }

        .folder-input-btn:hover {
            background: #6d28d9;
            transform: scale(1.05);
        }

        .folder-input-btn input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            top: 0;
            left: 0;
        }

        #notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 10001;
            transform: translateX(400px);
            transition: transform 0.3s;
            max-width: 300px;
        }

        #notification.show {
            transform: translateX(0);
        }

        #notification.success {
            background: #064e3b;
            color: #a7f3d0;
            border: 1px solid #047857;
        }

        #notification.error {
            background: #7f1d1d;
            color: #fca5a5;
            border: 1px solid #dc2626;
        }

        #notification.info {
            background: #1e3a8a;
            color: #93c5fd;
            border: 1px solid #2563eb;
        }

        #notification.warning {
            background: #7c2d12;
            color: #fed7aa;
            border: 1px solid #ea580c;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="sidebar">
            <div class="sidebar-icon" title="ÂØºÂÖ•ÁôΩÊùøÊñá‰ª∂">
                üìÇ
                <input type="file" id="file-input" accept=".canvas">
            </div>
            
            <div class="sidebar-icon" id="folder-btn" title="ÂØºÂÖ•ÂõæÁâáÊñá‰ª∂Â§π">
                üñºÔ∏è
                <span class="badge" id="image-count" style="display: none;">0</span>
            </div>
            
            <div class="sidebar-divider"></div>
            
            <div class="sidebar-bottom">
                <div class="sidebar-icon" title="ÂÖ≥‰∫é">
                    ‚ÑπÔ∏è
                </div>
            </div>
        </div>

        <div id="main-area">
            <div id="toolbar">
                <button class="toolbar-btn primary" id="export-btn" disabled>
                    üíæ ÂØºÂá∫ HTML
                </button>
                
                <div class="toolbar-divider"></div>
                
                <button class="toolbar-btn" id="reset-view-btn">
                    üéØ ÈáçÁΩÆËßÜÂõæ
                </button>
                
                <div class="toolbar-info">
                    <span id="node-count">ËäÇÁÇπ: 0</span>
                    <span id="edge-count">ËøûÁ∫ø: 0</span>
                    <span id="image-status"></span>
                </div>
            </div>

            <div id="canvas-workspace">
                <div id="canvas-viewport">
                    <div class="grid-background"></div>
                    <div id="canvas-content"></div>
                    
                    <div class="empty-state" id="empty-state">
                        <div class="empty-state-icon">üìä</div>
                        <div class="empty-state-text">Obsidian Canvas ËΩ¨Êç¢Âô®</div>
                        <div class="empty-state-hint">
                            <div>1Ô∏è‚É£ ÁÇπÂáªÂ∑¶‰æß üìÇ ÂØºÂÖ• .canvas Êñá‰ª∂</div>
                            <div style="margin-top:10px">2Ô∏è‚É£ ÁÇπÂáªÂ∑¶‰æß üñºÔ∏è ÈÄâÊã©ÂõæÁâáÊñá‰ª∂Â§π</div>
                        </div>
                    </div>
                </div>

                <div id="zoom-indicator">100%</div>

                <div id="shortcuts-hint">
                    <div class="shortcut-line">
                        <span class="shortcut-key">Space+Drag</span>
                        <span>ÁßªÂä®ÁîªÊùø</span>
                    </div>
                    <div class="shortcut-line">
                        <span class="shortcut-key">Space+Scroll</span>
                        <span>Áº©Êîæ</span>
                    </div>
                    <div class="shortcut-line">
                        <span class="shortcut-key">Shift+R</span>
                        <span>ÈáçÁΩÆËßÜÂõæ</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="folder-modal">
        <div class="modal-content">
            <div class="modal-icon">üìÅ</div>
            <div class="modal-title">ÈÄâÊã©ÂõæÁâáÊñá‰ª∂Â§π</div>
            <div class="modal-text">
                ÈÄâÊã©ÂåÖÂê´ÁôΩÊùøÂõæÁâáÁöÑÊñá‰ª∂Â§π<br>
                Â∑•ÂÖ∑Â∞ÜËá™Âä®Êâ´ÊèèÂπ∂ÂåπÈÖçÊâÄÊúâÂõæÁâá
            </div>
            <div>
                <button class="folder-input-btn">
                    üìÇ ÊµèËßàÊñá‰ª∂Â§π
                    <input type="file" id="folder-input" webkitdirectory directory multiple>
                </button>
            </div>
        </div>
    </div>

    <div id="notification"></div>

    <script>
        const CONFIG = {
            IMAGE_EXTENSIONS: ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg', '.bmp', '.tiff'],
            CONCURRENT_LOADS: 4,
        };

        let canvasData = null;
        let imageMap = new Map();
        let imageFileMap = new Map();
        let loadingCount = 0;
        let totalCount = 0;
        
        let viewState = {
            x: 0,
            y: 0,
            scale: 1,
            isPanning: false,
            startX: 0,
            startY: 0
        };

        const viewport = document.getElementById('canvas-viewport');
        const content = document.getElementById('canvas-content');
        const zoomIndicator = document.getElementById('zoom-indicator');
        const emptyState = document.getElementById('empty-state');
        const folderModal = document.getElementById('folder-modal');
        const folderBtn = document.getElementById('folder-btn');
        const imageCountBadge = document.getElementById('image-count');
        const imageStatus = document.getElementById('image-status');

        let spacePressed = false;

        document.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            return false;
        }, false);

        document.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            return false;
        }, false);

        document.addEventListener('dragenter', (e) => {
            e.preventDefault();
            e.stopPropagation();
            return false;
        }, false);

        document.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            return false;
        }, false);

        document.getElementById('file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    canvasData = JSON.parse(event.target.result);
                    console.log('Canvas loaded:', canvasData);
                    renderCanvas();
                    updateInfo();
                    resetView();
                    document.getElementById('export-btn').disabled = false;
                    emptyState.style.display = 'none';
                    updateImageStatus();
                    notify(`‚úÖ ÊàêÂäüÂä†ËΩΩÁôΩÊùø`, 'success');
                } catch (error) {
                    notify(`‚ùå Ëß£ÊûêÂ§±Ë¥•: ${error.message}`, 'error');
                    console.error(error);
                }
            };
            reader.readAsText(file);
            this.value = '';
        });

        folderBtn.addEventListener('click', () => {
            folderModal.classList.add('show');
        });

        folderModal.addEventListener('click', (e) => {
            if (e.target === folderModal) {
                folderModal.classList.remove('show');
            }
        });

        document.getElementById('folder-input').addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            
            if (files.length === 0) {
                notify('‚ö†Ô∏è Êú™ÈÄâÊã©‰ªª‰ΩïÊñá‰ª∂', 'warning');
                return;
            }

            folderModal.classList.remove('show');
            
            const imageFiles = files.filter(file => {
                const ext = '.' + file.name.split('.').pop().toLowerCase();
                return CONFIG.IMAGE_EXTENSIONS.includes(ext);
            });

            if (imageFiles.length === 0) {
                notify('‚ö†Ô∏è Êñá‰ª∂Â§π‰∏≠Ê≤°ÊúâÊâæÂà∞ÂõæÁâáÊñá‰ª∂', 'warning');
                return;
            }

            notify(`‚è≥ Ê≠£Âú®Âä†ËΩΩ ${imageFiles.length} Âº†ÂõæÁâá...`, 'info');
            await loadImages(imageFiles);
            
            if (canvasData) {
                renderCanvas();
            }

            e.target.value = '';
        });

        async function loadImages(files) {
            imageMap.clear();
            imageFileMap.clear();
            loadingCount = 0;
            totalCount = files.length;

            for (let i = 0; i < files.length; i += CONFIG.CONCURRENT_LOADS) {
const batch = files.slice(i, i + CONFIG.CONCURRENT_LOADS);
                
                await Promise.all(batch.map(file => {
                    return new Promise((resolve) => {
                        const reader = new FileReader();
                        
                        reader.onload = function(event) {
                            const dataUrl = event.target.result;
                            const relativePath = file.webkitRelativePath || file.name;
                            
                            imageMap.set(relativePath, dataUrl);
                            imageFileMap.set(file.name, dataUrl);
                            
                            loadingCount++;
                            updateImageStatus();
                            resolve();
                        };
                        
                        reader.onerror = function() {
                            loadingCount++;
                            updateImageStatus();
                            resolve();
                        };
                        
                        reader.readAsDataURL(file);
                    });
                }));
            }

            imageCountBadge.textContent = imageMap.size;
            imageCountBadge.style.display = 'block';
            notify(`‚úÖ ÊàêÂäüÂä†ËΩΩ ${imageMap.size} Âº†ÂõæÁâá`, 'success');
            updateImageStatus();
        }

        function findImageUrl(imagePath) {
            if (!imagePath) return null;

            if (imageMap.has(imagePath)) {
                return imageMap.get(imagePath);
            }

            const filename = imagePath.split('/').pop().split('\\').pop();
            
            if (imageFileMap.has(filename)) {
                return imageFileMap.get(filename);
            }

            const lowerFilename = filename.toLowerCase();
            for (let [name, url] of imageFileMap) {
                if (name.toLowerCase() === lowerFilename) {
                    return url;
                }
            }

            const nameWithoutExt = filename.replace(/\.[^/.]+$/, '').toLowerCase();
            for (let [name, url] of imageFileMap) {
                const storedNameWithoutExt = name.replace(/\.[^/.]+$/, '').toLowerCase();
                if (storedNameWithoutExt === nameWithoutExt) {
                    return url;
                }
            }

            return null;
        }

        function updateImageStatus() {
            if (!canvasData) {
                imageStatus.innerHTML = '';
                return;
            }

            const imageNodes = canvasData.nodes.filter(node => {
                if (node.type === 'file') {
                    const path = node.file || '';
                    return /\.(jpg|jpeg|png|gif|webp|svg|bmp|tiff)$/i.test(path);
                }
                return false;
            });

            const matched = imageNodes.filter(node => {
                return findImageUrl(node.file) !== null;
            }).length;

            if (imageNodes.length > 0) {
                imageStatus.innerHTML = `<span style="color: ${matched === imageNodes.length ? '#10b981' : '#f59e0b'};">ÂõæÁâá: ${matched}/${imageNodes.length}</span>`;
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !spacePressed) {
                e.preventDefault();
                spacePressed = true;
                viewport.classList.add('space-mode');
            }

            if (e.shiftKey && e.code === 'KeyR') {
                e.preventDefault();
                resetView();
                notify('üéØ ËßÜÂõæÂ∑≤ÈáçÁΩÆ', 'info');
            }

            if (e.key === 'Escape' && folderModal.classList.contains('show')) {
                folderModal.classList.remove('show');
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                spacePressed = false;
                viewport.classList.remove('space-mode');
                viewState.isPanning = false;
                viewport.classList.remove('dragging');
            }
        });

        viewport.addEventListener('mousedown', (e) => {
            if (spacePressed && e.button === 0) {
                e.preventDefault();
                viewState.isPanning = true;
                viewState.startX = e.clientX - viewState.x;
                viewState.startY = e.clientY - viewState.y;
                viewport.classList.add('dragging');
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (viewState.isPanning) {
                viewState.x = e.clientX - viewState.startX;
                viewState.y = e.clientY - viewState.startY;
                updateTransform();
            }
        });

        document.addEventListener('mouseup', () => {
            if (viewState.isPanning) {
                viewState.isPanning = false;
                viewport.classList.remove('dragging');
            }
        });

        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();

            const delta = -e.deltaY * 0.002;
            const newScale = Math.min(Math.max(0.1, viewState.scale * (1 + delta)), 5);
            
            const rect = viewport.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const beforeX = (mouseX - viewState.x) / viewState.scale;
            const beforeY = (mouseY - viewState.y) / viewState.scale;
            
            viewState.scale = newScale;
            
            viewState.x = mouseX - beforeX * viewState.scale;
            viewState.y = mouseY - beforeY * viewState.scale;
            
            updateTransform();
            updateZoomIndicator();
        }, { passive: false });

        document.getElementById('export-btn').addEventListener('click', exportHTML);
        document.getElementById('reset-view-btn').addEventListener('click', () => {
            resetView();
            notify('üéØ ËßÜÂõæÂ∑≤ÈáçÁΩÆ', 'info');
        });

        function updateTransform() {
            content.style.transform = `translate(${viewState.x}px, ${viewState.y}px) scale(${viewState.scale})`;
        }

        function updateZoomIndicator() {
            zoomIndicator.textContent = Math.round(viewState.scale * 100) + '%';
        }

        function resetView() {
            viewState.x = 100;
            viewState.y = 100;
            viewState.scale = 1;
            updateTransform();
            updateZoomIndicator();
        }

        function normalizeColor(color) {
            if (!color) return '#888888';
            
            if (color.startsWith('#')) {
                return color;
            }
            
            const colorMap = {
                '1': '#d07373',
                '2': '#e69650',
                '3': '#d0b44b',
                '4': '#64b45a',
                '5': '#648cc8',
                '6': '#9664c8',
                'color-1': '#d07373',
                'color-2': '#e69650',
                'color-3': '#d0b44b',
                'color-4': '#64b45a',
                'color-5': '#648cc8',
                'color-6': '#9664c8',
            };
            
            return colorMap[color] || '#888888';
        }

        function renderCanvas() {
            if (!canvasData || !canvasData.nodes) return;

            content.innerHTML = '';

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            canvasData.nodes.forEach(node => {
                const nodeMinX = node.x;
                const nodeMinY = node.y;
                const nodeMaxX = node.x + (node.width || 250);
                const nodeMaxY = node.y + (node.height || 100);
                
                minX = Math.min(minX, nodeMinX);
                minY = Math.min(minY, nodeMinY);
                maxX = Math.max(maxX, nodeMaxX);
                maxY = Math.max(maxY, nodeMaxY);
            });

            if (!isFinite(minX)) {
                minX = minY = 0;
                maxX = 1000;
                maxY = 1000;
            }

            const padding = 100;
            const offsetX = minX - padding;
            const offsetY = minY - padding;
            const width = maxX - minX + padding * 2;
            const height = maxY - minY + padding * 2;

            content.style.width = width + 'px';
            content.style.height = height + 'px';

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.classList.add('canvas-svg');
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
            svg.style.zIndex = '1';
            
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            svg.appendChild(defs);
            
            content.appendChild(svg);

            canvasData.nodes.filter(n => n.type === 'group').forEach(node => {
                const nodeEl = createNodeElement(node, offsetX, offsetY);
                if (nodeEl) content.appendChild(nodeEl);
            });

            if (canvasData.edges && canvasData.edges.length > 0) {
                canvasData.edges.forEach((edge) => {
                    drawEdgeLine(svg, edge, offsetX, offsetY);
                });
            }

            canvasData.nodes.filter(n => n.type !== 'group').forEach(node => {
                const nodeEl = createNodeElement(node, offsetX, offsetY);
                if (nodeEl) content.appendChild(nodeEl);
            });
        }

function createNodeElement(node, offsetX, offsetY) {
    const div = document.createElement('div');
    div.className = 'canvas-node';
    div.dataset.nodeId = node.id;
    
    const x = node.x - offsetX;
    const y = node.y - offsetY;
    const w = node.width || 250;
    const h = node.height || 100;

    div.style.left = x + 'px';
    div.style.top = y + 'px';
    div.style.width = w + 'px';
    div.style.height = h + 'px';

    if (node.color) {
        if (node.color.startsWith('#')) {
            const rgba = hexToRgba(node.color, 0.08);
            const rgbaBorder = hexToRgba(node.color, 0.2);
            div.style.background = rgba;
            div.style.borderColor = rgbaBorder;
        } else {
            const colorNum = node.color.replace('color-', '');
            div.classList.add('color-' + colorNum);
        }
    }

    if (node.styleAttributes) {
        const attrs = node.styleAttributes;
        if (attrs.textAlign) {
            div.classList.add('text-align-' + attrs.textAlign);
        }
        if (attrs.shape) {
            div.classList.add('shape-' + attrs.shape);
        }
        if (attrs.border === 'invisible') {
            div.classList.add('border-invisible');
        }
    }

    if (node.type === 'text') {
        div.classList.add('text');
        // ‰øùÁïôÊç¢Ë°åÁ¨¶Ôºå‰ΩøÁî®ÁôΩÁ©∫‰øùÁïô
        div.style.whiteSpace = 'pre-wrap';
        div.style.wordWrap = 'break-word';
        // ‰ΩøÁî® marked Ê∏≤Êüì Markdown
        if (typeof marked !== 'undefined') {
            div.innerHTML = marked.parse(node.text || '');
        } else {
            div.textContent = node.text || '';
        }
            } else if (node.type === 'file') {
                const filePath = node.file || '';
                const isImage = /\.(jpg|jpeg|png|gif|webp|svg|bmp|tiff)$/i.test(filePath);
                
                if (isImage) {
                    div.classList.add('image');
         const imageUrl = findImageUrl(filePath);
                    
                    if (imageUrl) {
                        const img = document.createElement('img');
                        img.src = imageUrl;
                        img.alt = filePath.split('/').pop();
                        div.appendChild(img);
                    } else {
                        div.classList.add('missing-image');
                        const filename = filePath.split('/').pop();
                        div.innerHTML = `<div class="missing-image-icon">üñºÔ∏è</div><div class="missing-image-text">${escapeHtml(filename)}</div>`;
                    }
                } else {
                    div.classList.add('file');
                    const fileName = filePath.split('/').pop() || 'file';
                    div.innerHTML = `<div class="file-name">üìÑ ${escapeHtml(fileName)}</div>`;
                }
            } else if (node.type === 'group') {
                div.classList.add('group');
                if (node.label) {
                    const label = document.createElement('div');
                    label.className = 'group-label';
                    label.textContent = node.label;
                    div.appendChild(label);
                }
            }

            return div;
        }

        // ÁªòÂà∂ËøûÁ∫ø - ÊîØÊåÅÂ§öÁßçË∑ØÂæÑÁÆóÊ≥ï
        function drawEdgeLine(svg, edge, offsetX, offsetY) {
            const fromNode = canvasData.nodes.find(n => n.id === edge.fromNode);
            const toNode = canvasData.nodes.find(n => n.id === edge.toNode);
            
            if (!fromNode || !toNode) {
                console.warn('Êâæ‰∏çÂà∞ËøûÁ∫øÁöÑËµ∑ÁÇπÊàñÁªàÁÇπ:', edge);
                return;
            }

            const from = getNodeEdgePoint(fromNode, edge.fromSide || 'right', offsetX, offsetY);
            const to = getNodeEdgePoint(toNode, edge.toSide || 'left', offsetX, offsetY);

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.classList.add('edge-line');

            // Ê†πÊçÆ pathfindingMethod ÈÄâÊã©‰∏çÂêåÁöÑË∑ØÂæÑÁÆóÊ≥ï
            const pathfindingMethod = edge.styleAttributes?.pathfindingMethod || 'default';
            let pathData;

            if (pathfindingMethod === 'direct') {
                // Áõ¥Á∫ø
                pathData = `M ${from.x} ${from.y} L ${to.x} ${to.y}`;
            } else if (pathfindingMethod === 'square') {
                // ÊäòÁ∫øÔºàÁõ¥ËßíËøûÊé•Ôºâ
                pathData = createSquarePath(from, to, edge.fromSide, edge.toSide);
            } else if (pathfindingMethod === 'a-star') {
                // A* Ë∑ØÂæÑÔºàÁÆÄÂåñÁâàÔºå‰ΩøÁî®ÊäòÁ∫øËøë‰ººÔºâ
                pathData = createAStarPath(from, to, edge.fromSide, edge.toSide);
            } else {
                // ÈªòËÆ§Ë¥ùÂ°ûÂ∞îÊõ≤Á∫ø
                const dx = to.x - from.x;
                pathData = `M ${from.x} ${from.y} C ${from.x + dx * 0.5} ${from.y}, ${to.x - dx * 0.5} ${to.y}, ${to.x} ${to.y}`;
            }
            
            path.setAttribute('d', pathData);
            
            const edgeColor = normalizeColor(edge.color);
            path.setAttribute('stroke', edgeColor);
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');

            if (edge.styleAttributes && edge.styleAttributes.path) {
                const pathStyle = edge.styleAttributes.path;
                if (pathStyle === 'short-dashed') {
                    path.setAttribute('stroke-dasharray', '5,5');
                } else if (pathStyle === 'long-dashed') {
                    path.setAttribute('stroke-dasharray', '10,10');
                } else if (pathStyle === 'dotted') {
                    path.setAttribute('stroke-dasharray', '2,4');
                }
            }

            let hasArrow = true;
            if (edge.styleAttributes && edge.styleAttributes.arrow === null) {
                hasArrow = false;
            }

            if (hasArrow) {
                const arrowType = edge.styleAttributes?.arrow || 'default';
                const sanitizedColor = edgeColor.replace(/[^a-zA-Z0-9]/g, '');
                const markerId = `arrow-${sanitizedColor}-${arrowType}`;
                
                if (!svg.querySelector(`#${markerId}`)) {
                    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                    marker.setAttribute('id', markerId);
                    marker.setAttribute('markerWidth', '10');
                    marker.setAttribute('markerHeight', '10');
                    marker.setAttribute('refX', '9');
                    marker.setAttribute('refY', '3');
                    marker.setAttribute('orient', 'auto');

                    if (arrowType === 'triangle-outline') {
                        // Á©∫ÂøÉ‰∏âËßíÁÆ≠Â§¥
                        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        polygon.setAttribute('points', '0 0, 10 3, 0 6');
                        polygon.setAttribute('fill', 'none');
                        polygon.setAttribute('stroke', edgeColor);
                        polygon.setAttribute('stroke-width', '1');
                        marker.appendChild(polygon);
                    } else if (arrowType === 'thin-triangle') {
                        // ÁªÜÈïø‰∏âËßíÁÆ≠Â§¥
                        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        polygon.setAttribute('points', '0 1, 12 3, 0 5');
                        polygon.setAttribute('fill', edgeColor);
                        marker.setAttribute('markerWidth', '12');
                        marker.setAttribute('refX', '11');
                        marker.appendChild(polygon);
                    } else {
                        // ÈªòËÆ§ÂÆûÂøÉ‰∏âËßíÁÆ≠Â§¥
                        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        polygon.setAttribute('points', '0 0, 10 3, 0 6');
                        polygon.setAttribute('fill', edgeColor);
                        marker.appendChild(polygon);
                    }

                    svg.querySelector('defs').appendChild(marker);
                }

                path.setAttribute('marker-end', `url(#${markerId})`);
            }

            svg.appendChild(path);
        }

        // ÂàõÂª∫ÊäòÁ∫øË∑ØÂæÑ
        function createSquarePath(from, to, fromSide, toSide) {
            const midX = (from.x + to.x) / 2;
            const midY = (from.y + to.y) / 2;

            // Ê†πÊçÆËµ∑ÁÇπÂíåÁªàÁÇπÁöÑÊñπÂêëÈÄâÊã©ÊäòÁ∫øË∑ØÂæÑ
            if ((fromSide === 'right' || fromSide === 'left') && (toSide === 'right' || toSide === 'left')) {
                // Ê∞¥Âπ≥ÊñπÂêë
                return `M ${from.x} ${from.y} L ${midX} ${from.y} L ${midX} ${to.y} L ${to.x} ${to.y}`;
            } else if ((fromSide === 'top' || fromSide === 'bottom') && (toSide === 'top' || toSide === 'bottom')) {
                // ÂûÇÁõ¥ÊñπÂêë
                return `M ${from.x} ${from.y} L ${from.x} ${midY} L ${to.x} ${midY} L ${to.x} ${to.y}`;
            } else {
                // Ê∑∑ÂêàÊñπÂêë
                return `M ${from.x} ${from.y} L ${from.x} ${to.y} L ${to.x} ${to.y}`;
            }
        }

        // ÂàõÂª∫ A* È£éÊ†ºË∑ØÂæÑÔºàÁÆÄÂåñÁâàÔºâ
        function createAStarPath(from, to, fromSide, toSide) {
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            
            // ‰ΩøÁî®Â§ö‰∏™ËΩ¨ÊäòÁÇπÊ®°Êãü A* Ë∑ØÂæÑ
            const points = [];
            points.push(`M ${from.x} ${from.y}`);
            
            if (Math.abs(dx) > Math.abs(dy)) {
                // ‰∏ªË¶ÅÊòØÊ∞¥Âπ≥ÁßªÂä®
                const step1X = from.x + dx * 0.3;
                const step2X = from.x + dx * 0.7;
                points.push(`L ${step1X} ${from.y}`);
                points.push(`L ${step2X} ${to.y}`);
            } else {
                // ‰∏ªË¶ÅÊòØÂûÇÁõ¥ÁßªÂä®
                const step1Y = from.y + dy * 0.3;
                const step2Y = from.y + dy * 0.7;
                points.push(`L ${from.x} ${step1Y}`);
                points.push(`L ${to.x} ${step2Y}`);
            }
            
            points.push(`L ${to.x} ${to.y}`);
            return points.join(' ');
        }

        function getNodeEdgePoint(node, side, offsetX, offsetY) {
            const x = node.x - offsetX;
            const y = node.y - offsetY;
            const w = node.width || 250;
            const h = node.height || 100;

            const points = {
                top: { x: x + w / 2, y: y },
                right: { x: x + w, y: y + h / 2 },
                bottom: { x: x + w / 2, y: y + h },
                left: { x: x, y: y + h / 2 }
            };

            return points[side] || { x: x + w / 2, y: y + h / 2 };
        }

        function updateInfo() {
            if (!canvasData) return;
            document.getElementById('node-count').textContent = `ËäÇÁÇπ: ${canvasData.nodes?.length || 0}`;
            document.getElementById('edge-count').textContent = `ËøûÁ∫ø: ${canvasData.edges?.length || 0}`;
        }

        function exportHTML() {
            if (!canvasData) return;
            
            notify('‚è≥ Ê≠£Âú®ÂØºÂá∫...', 'info');
            setTimeout(() => {
                const html = generateHTML();
                downloadFile('canvas-export.html', html);
                notify('‚úÖ HTML Â∑≤ÂØºÂá∫ÔºÅËØ∑Â∞Ü HTML Êñá‰ª∂Âíå "images" Êñá‰ª∂Â§πÊîæÂú®Âêå‰∏ÄÁõÆÂΩï', 'success');
            }, 100);
        }

function generateHTML() {
    // ============ ÂÆö‰πâÊâÄÊúâËæÖÂä©ÂáΩÊï∞ ============
    function getNodeEdgePoint(node, side, offsetX, offsetY) {
        const x = node.x - offsetX;
        const y = node.y - offsetY;
        const w = node.width || 250;
        const h = node.height || 100;

        const points = {
            top: { x: x + w / 2, y: y },
            right: { x: x + w, y: y + h / 2 },
            bottom: { x: x + w / 2, y: y + h },
            left: { x: x, y: y + h / 2 }
        };

        return points[side] || { x: x + w / 2, y: y + h / 2 };
    }

    function createSquarePath(from, to, fromSide, toSide) {
        const midX = (from.x + to.x) / 2;
        const midY = (from.y + to.y) / 2;

        if ((fromSide === 'right' || fromSide === 'left') && (toSide === 'right' || toSide === 'left')) {
            return `M ${from.x} ${from.y} L ${midX} ${from.y} L ${midX} ${to.y} L ${to.x} ${to.y}`;
        } else if ((fromSide === 'top' || fromSide === 'bottom') && (toSide === 'top' || toSide === 'bottom')) {
            return `M ${from.x} ${from.y} L ${from.x} ${midY} L ${to.x} ${midY} L ${to.x} ${to.y}`;
        } else {
            return `M ${from.x} ${from.y} L ${from.x} ${to.y} L ${to.x} ${to.y}`;
        }
    }

    function createAStarPath(from, to, fromSide, toSide) {
        const dx = to.x - from.x;
        const dy = to.y - from.y;
        
        const points = [];
        points.push(`M ${from.x} ${from.y}`);
        
        if (Math.abs(dx) > Math.abs(dy)) {
            const step1X = from.x + dx * 0.3;
            const step2X = from.x + dx * 0.7;
            points.push(`L ${step1X} ${from.y}`);
            points.push(`L ${step2X} ${to.y}`);
        } else {
            const step1Y = from.y + dy * 0.3;
            const step2Y = from.y + dy * 0.7;
            points.push(`L ${from.x} ${step1Y}`);
            points.push(`L ${to.x} ${step2Y}`);
        }
        
        points.push(`L ${to.x} ${to.y}`);
        return points.join(' ');
    }

    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
    }

    function generateNodeHTML(node, offsetX, offsetY) {
        const x = node.x - offsetX;
        const y = node.y - offsetY;
        const w = node.width || 250;
        const h = node.height || 100;

        let classes = ['canvas-node'];
        let styles = `left:${x}px;top:${y}px;width:${w}px;height:${h}px;white-space:pre-wrap;word-wrap:break-word;`;
            
        if (node.color) {
            if (node.color.startsWith('#')) {
                const rgba = hexToRgba(node.color, 0.08);
                const rgbaBorder = hexToRgba(node.color, 0.2);
                styles += `background:${rgba};border-color:${rgbaBorder};`;
            } else {
                const colorNum = node.color.replace('color-', '');
                classes.push('color-' + colorNum);
            }
        }

        if (node.styleAttributes) {
            if (node.styleAttributes.textAlign) {
                classes.push('text-align-' + node.styleAttributes.textAlign);
            }
            if (node.styleAttributes.shape) {
                classes.push('shape-' + node.styleAttributes.shape);
            }
            if (node.styleAttributes.border === 'invisible') {
                classes.push('border-invisible');
            }
        }

        let content = '';
        if (node.type === 'text') {
            classes.push('text');
            content = escapeHtml(node.text || '');
        } else if (node.type === 'file') {
            const filePath = node.file || '';
            const isImage = /\.(jpg|jpeg|png|gif|webp|svg|bmp|tiff)$/i.test(filePath);
            
            if (isImage) {
                classes.push('image');
                const filename = filePath.split('/').pop().split('\\').pop();
                const imagePath = `./images/${filename}`;
                
                content = `<img src="${imagePath}" alt="${escapeHtml(filename)}" style="width:100%;height:100%;object-fit:contain;" onerror="this.style.display='none';this.parentElement.innerHTML='<div class=\\'missing-image-icon\\'>üñºÔ∏è</div><div class=\\'missing-image-text\\'>${escapeHtml(filename)}</div>'">`;
            } else {
                classes.push('file');
                const fileName = filePath.split('/').pop() || 'file';
                content = `<div class="file-name">üìÑ ${escapeHtml(fileName)}</div>`;
            }
        } else if (node.type === 'group') {
            classes.push('group');
            if (node.label) {
                content = `<div class="group-label">${escapeHtml(node.label)}</div>`;
            }
        }

        return `        <div class="${classes.join(' ')}" style="${styles}">${content}</div>\n`;
    }

    // ============ ‰∏ªÂáΩÊï∞ÈÄªËæëÂºÄÂßã ============
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    canvasData.nodes.forEach(node => {
        minX = Math.min(minX, node.x);
        minY = Math.min(minY, node.y);
        maxX = Math.max(maxX, node.x + (node.width || 250));
        maxY = Math.max(maxY, node.y + (node.height || 100));
    });

    if (!isFinite(minX)) {
        minX = minY = 0;
        maxX = 1000;
        maxY = 1000;
    }

    const padding = 100;
    const width = maxX - minX + padding * 2;
    const height = maxY - minY + padding * 2;
    const offsetX = minX - padding;
    const offsetY = minY - padding;

    let html = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Export</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"><\/script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #1a1a1a;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }
        
        #canvas-viewport {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            cursor: default;
        }
        
        #canvas-viewport.space-mode {
            cursor: grab;
        }
        
        #canvas-viewport.dragging {
            cursor: grabbing;
        }
        
        #canvas-content {
            position: absolute;
            transform-origin: 0 0;
            will-change: transform;
        }
        
        .grid-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
        }
        
        #zoom-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #333;
            color: #fff;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            font-family: monospace;
            pointer-events: none;
            z-index: 1000;
        }
        
        #shortcuts-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #333;
            color: #888;
            padding: 12px;
            border-radius: 6px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            line-height: 1.6;
        }
        
        .shortcut-line {
            display: flex;
            gap: 10px;
        }
        
        .shortcut-key {
            color: #7c3aed;
            font-family: monospace;
        }
        
        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            border-radius: 8px;
            overflow: hidden;
            z-index: 999;
            cursor: grab;
        }
        
        #minimap:active {
            cursor: grabbing;
        }
        
        #minimap-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        #minimap-viewport {
            position: absolute;
            border: 2px solid #7c3aed;
            background: rgba(124, 58, 237, 0.1);
            pointer-events: none;
            box-sizing: border-box;
        }
        
        .canvas-node { 
            position: absolute; 
            background: rgba(45, 45, 45, 0.15); 
            border: 1px solid rgba(70, 70, 70, 0.3); 
            border-radius: 8px; 
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            line-height: 1.5;
            overflow: auto;
            user-select: text;
        }
        
        .canvas-node.text { 
            color: #e0e0e0; 
            font-size: 13px; 
            white-space: pre-wrap; 
            word-wrap: break-word;
            word-break: break-word;
            overflow-wrap: break-word;
        }
        
        .canvas-node.text h1, .canvas-node.text h2, .canvas-node.text h3,
        .canvas-node.text h4, .canvas-node.text h5, .canvas-node.text h6 {
            margin-top: 0.5em; margin-bottom: 0.5em; font-weight: 600;
        }
        .canvas-node.text h1 { font-size: 1.8em; }
        .canvas-node.text h2 { font-size: 1.5em; }
        .canvas-node.text h3 { font-size: 1.3em; }
        .canvas-node.text p { margin: 0.5em 0; }
        .canvas-node.text ul, .canvas-node.text ol { margin-left: 1.5em; margin-top: 0.5em; margin-bottom: 0.5em; }
        .canvas-node.text code { background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px; font-family: monospace; font-size: 0.9em; }
        .canvas-node.text pre { background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; overflow-x: auto; margin: 0.5em 0; }
        .canvas-node.text pre code { background: none; padding: 0; }
        .canvas-node.text blockquote { border-left: 3px solid #7c3aed; padding-left: 1em; margin: 0.5em 0; color: #aaa; }
        .canvas-node.text a { color: #7c3aed; text-decoration: none; }
        .canvas-node.text a:hover { text-decoration: underline; }
        .canvas-node.text strong { font-weight: 600; }
        .canvas-node.text em { font-style: italic; }
        .canvas-node.text hr { border: none; border-top: 1px solid rgba(255,255,255,0.1); margin: 1em 0; }
        
        .canvas-node.file { background: rgba(26, 26, 26, 0.15); border: 2px solid rgba(70, 70, 70, 0.3); display: flex; align-items: center; justify-content: center; }
        .canvas-node.image { padding: 0; background: rgba(26, 26, 26, 0.15); display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .canvas-node.image img { width: 100%; height: 100%; object-fit: contain; }
        .canvas-node.group { background: rgba(45, 45, 45, 0.05); border: 2px solid rgba(85, 85, 85, 0.3); z-index: -1; }
        
        .shape-ellipse { border-radius: 50%; }
        .shape-predefined-process { border-left-width: 4px; border-right-width: 4px; }
        .shape-document { border-bottom: 3px solid currentColor; border-radius: 4px; }
        
        .text-align-left { text-align: left; }
        .text-align-center { text-align: center; }
        .text-align-right { text-align: right; }
        .border-invisible { border: none !important; background: transparent !important; }
        
        .color-1 { background: rgba(208, 115, 115, 0.08); border-color: rgba(208, 115, 115, 0.2); color: rgba(208, 115, 115, 1); }
        .color-2 { background: rgba(230, 150, 80, 0.08); border-color: rgba(230, 150, 80, 0.2); color: rgba(230, 150, 80, 1); }
        .color-3 { background: rgba(208, 180, 75, 0.08); border-color: rgba(208, 180, 75, 0.2); color: rgba(208, 180, 75, 1); }
        .color-4 { background: rgba(100, 180, 90, 0.08); border-color: rgba(100, 180, 90, 0.2); color: rgba(100, 180, 90, 1); }
        .color-5 { background: rgba(100, 140, 200, 0.08); border-color: rgba(100, 140, 200, 0.2); color: rgba(100, 140, 200, 1); }
        .color-6 { background: rgba(150, 100, 200, 0.08); border-color: rgba(150, 100, 200, 0.2); color: rgba(150, 100, 200, 1); }
        
        .file-name { color: #7c3aed; font-size: 12px; text-align: center; }
        .group-label { position: absolute; top: 8px; left: 12px; background: rgba(45, 45, 45, 0.8); padding: 4px 8px; border-radius: 4px; font-size: 12px; color: #bbb; }
        .missing-image { display: flex; flex-direction: column; gap: 8px; background: rgba(45, 45, 45, 0.15); }
        .missing-image-icon { font-size: 24px; opacity: 0.5; }
        .missing-image-text { font-size: 10px; color: #888; text-align: center; }
        
        .canvas-svg {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 0;
        }
    </style>
</head>
<body>
    <div id="canvas-viewport">
        <div class="grid-background"></div>
        <div id="canvas-content">
            <svg id="canvas-svg" class="canvas-svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
                <defs>
`;

    if (canvasData.edges && canvasData.edges.length > 0) {
        const edgeArrows = new Map();
        canvasData.edges.forEach(edge => {
            const color = normalizeColor(edge.color);
            const arrowType = edge.styleAttributes?.arrow || 'default';
            const key = `${color}-${arrowType}`;
            edgeArrows.set(key, { color, arrowType });
        });

        edgeArrows.forEach((value, key) => {
            const sanitizedKey = key.replace(/[^a-zA-Z0-9-]/g, '');
            const { color, arrowType } = value;
            
            if (arrowType === 'triangle-outline') {
                html += `                <marker id="arrow-${sanitizedKey}" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                    <polygon points="0 0, 10 3, 0 6" fill="none" stroke="${color}" stroke-width="1"/>
                </marker>\n`;
            } else if (arrowType === 'thin-triangle') {
                html += `                <marker id="arrow-${sanitizedKey}" markerWidth="12" markerHeight="10" refX="11" refY="3" orient="auto">
                    <polygon points="0 1, 12 3, 0 5" fill="${color}"/>
                </marker>\n`;
            } else {
                html += `                <marker id="arrow-${sanitizedKey}" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                    <polygon points="0 0, 10 3, 0 6" fill="${color}"/>
                </marker>\n`;
            }
        });
    }

    html += `                </defs>\n`;

    if (canvasData.edges && canvasData.edges.length > 0) {
        canvasData.edges.forEach(edge => {
            const fromNode = canvasData.nodes.find(n => n.id === edge.fromNode);
            const toNode = canvasData.nodes.find(n => n.id === edge.toNode);
            
            if (fromNode && toNode) {
                const from = getNodeEdgePoint(fromNode, edge.fromSide || 'right', offsetX, offsetY);
                const to = getNodeEdgePoint(toNode, edge.toSide || 'left', offsetX, offsetY);
                
                const pathfindingMethod = edge.styleAttributes?.pathfindingMethod || 'default';
                let pathData;

                if (pathfindingMethod === 'direct') {
                    pathData = `M ${from.x} ${from.y} L ${to.x} ${to.y}`;
                } else if (pathfindingMethod === 'square') {
                    pathData = createSquarePath(from, to, edge.fromSide, edge.toSide);
                } else if (pathfindingMethod === 'a-star') {
                    pathData = createAStarPath(from, to, edge.fromSide, edge.toSide);
                } else {
                    const dx = to.x - from.x;
                    pathData = `M ${from.x} ${from.y} C ${from.x + dx * 0.5} ${from.y}, ${to.x - dx * 0.5} ${to.y}, ${to.x} ${to.y}`;
                }
                
                let dasharray = '';
                if (edge.styleAttributes?.path === 'short-dashed') {
                    dasharray = ' stroke-dasharray="5,5"';
                } else if (edge.styleAttributes?.path === 'long-dashed') {
                    dasharray = ' stroke-dasharray="10,10"';
                } else if (edge.styleAttributes?.path === 'dotted') {
                    dasharray = ' stroke-dasharray="2,4"';
                }
                
                const edgeColor = normalizeColor(edge.color);
                const arrowType = edge.styleAttributes?.arrow || 'default';
                const sanitizedKey = (edgeColor + '-' + arrowType).replace(/[^a-zA-Z0-9-]/g, '');
                
                let markerEnd = '';
                if (!(edge.styleAttributes && edge.styleAttributes.arrow === null)) {
                    markerEnd = ' marker-end="url(#arrow-' + sanitizedKey + ')"';
                }
                
                html += '<path d="' + pathData + '" stroke="' + edgeColor + '" stroke-width="2" fill="none"' + dasharray + markerEnd + '/>\n';
            }
        });
    }

    html += `            </svg>
`;

    // Ê∑ªÂä†ÁªÑËäÇÁÇπ
    canvasData.nodes.filter(n => n.type === 'group').forEach(node => {
        html += generateNodeHTML(node, offsetX, offsetY);
    });

    // Ê∑ªÂä†ÂÖ∂‰ªñËäÇÁÇπ
    canvasData.nodes.filter(n => n.type !== 'group').forEach(node => {
        html += generateNodeHTML(node, offsetX, offsetY);
    });

    html += `        </div>
        
        <div id="minimap">
            <canvas id="minimap-canvas"></canvas>
            <div id="minimap-viewport"></div>
        </div>
        
        <div id="zoom-indicator">100%</div>
        
        <div id="shortcuts-hint">
            <div class="shortcut-line">
                <span class="shortcut-key">Space+Drag</span>
                <span>ÁßªÂä®ÁîªÊùø</span>
            </div>
            <div class="shortcut-line">
                <span class="shortcut-key">Space+Scroll</span>
                <span>Áº©Êîæ</span>
            </div>
        </div>
    </div>

    <script>
        const viewport = document.getElementById('canvas-viewport');
        const content = document.getElementById('canvas-content');
        const zoomIndicator = document.getElementById('zoom-indicator');
        const minimap = document.getElementById('minimap');
        const minimapCanvas = document.getElementById('minimap-canvas');
        const minimapViewport = document.getElementById('minimap-viewport');
        const minimapCtx = minimapCanvas.getContext('2d');
        
        let viewState = {
            x: 100,
            y: 100,
            scale: 1,
            isPanning: false,
            startX: 0,
            startY: 0
        };
        
        let minimapDragging = false;
        let canvasWidth = ${width};
        let canvasHeight = ${height};
        
        let spacePressed = false;
        
        // Ê∏≤Êüì Markdown
        document.querySelectorAll('.canvas-node.text').forEach(node => {
            if (typeof marked !== 'undefined' && node.textContent) {
                const originalText = node.textContent;
                node.innerHTML = marked.parse(originalText);
            }
        });
        
        // ÂàùÂßãÂåñÂ∞èÂú∞Âõæ
        function initMinimap() {
            minimapCanvas.width = minimap.clientWidth;
            minimapCanvas.height = minimap.clientHeight;
            drawMinimap();
        }
        
        function drawMinimap() {
            const w = minimapCanvas.width;
            const h = minimapCanvas.height;
            
            minimapCtx.fillStyle = 'rgba(20, 20, 20, 1)';
            minimapCtx.fillRect(0, 0, w, h);
            
            const scaleX = w / canvasWidth;
            const scaleY = h / canvasHeight;
            const scale = Math.min(scaleX, scaleY);
            
            const nodes = document.querySelectorAll('.canvas-node');
            nodes.forEach(node => {
                const left = parseFloat(node.style.left);
                const top = parseFloat(node.style.top);
                const nodeWidth = parseFloat(node.style.width);
                const nodeHeight = parseFloat(node.style.height);
                
                const x = left * scale;
                const y = top * scale;
                const width = nodeWidth * scale;
                const height = nodeHeight * scale;
                
                if (node.classList.contains('group')) {
                    minimapCtx.fillStyle = 'rgba(85, 85, 85, 0.4)';
                } else if (node.classList.contains('image')) {
                    minimapCtx.fillStyle = 'rgba(100, 140, 200, 0.6)';
                } else if (node.classList.contains('text')) {
                    minimapCtx.fillStyle = 'rgba(150, 100, 200, 0.6)';
                } else {
                    minimapCtx.fillStyle = 'rgba(124, 58, 237, 0.5)';
                }
                
                minimapCtx.fillRect(x, y, width, height);
            });
            
            updateMinimapViewport();
        }
        
        function updateMinimapViewport() {
            const w = minimapCanvas.width;
            const h = minimapCanvas.height;
            
            const scaleX = w / canvasWidth;
            const scaleY = h / canvasHeight;
            const scale = Math.min(scaleX, scaleY);
            
            const vw = viewport.clientWidth;
            const vh = viewport.clientHeight;
            
            const viewportX = (-viewState.x) * scale / viewState.scale;
            const viewportY = (-viewState.y) * scale / viewState.scale;
            const viewportWidth = (vw / viewState.scale) * scale;
            const viewportHeight = (vh / viewState.scale) * scale;
            
            minimapViewport.style.left = Math.max(0, Math.min(w - viewportWidth, viewportX)) + 'px';
            minimapViewport.style.top = Math.max(0, Math.min(h - viewportHeight, viewportY)) + 'px';
            minimapViewport.style.width = viewportWidth + 'px';
            minimapViewport.style.height = viewportHeight + 'px';
        }
        
        minimapViewport.addEventListener('mousedown', (e) => {
            minimapDragging = true;
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (minimapDragging) {
                const rect = minimapCanvas.getBoundingClientRect();
                const miniX = e.clientX - rect.left;
                const miniY = e.clientY - rect.top;
                
                const w = minimapCanvas.width;
                const h = minimapCanvas.height;
                const scaleX = w / canvasWidth;
                const scaleY = h / canvasHeight;
                const scale = Math.min(scaleX, scaleY);
                
                const vw = viewport.clientWidth;
                const vh = viewport.clientHeight;
                
                const centerX = (miniX / scale) - (vw / (2 * viewState.scale));
                const centerY = (miniY / scale) - (vh / (2 * viewState.scale));
                
                viewState.x = -centerX * viewState.scale;
                viewState.y = -centerY * viewState.scale;
                updateTransform();
                updateMinimapViewport();
            } else if (viewState.isPanning) {
                viewState.x = e.clientX - viewState.startX;
                viewState.y = e.clientY - viewState.startY;
                updateTransform();
                updateMinimapViewport();
            }
        });
        
        document.addEventListener('mouseup', () => {
            minimapDragging = false;
            if (viewState.isPanning) {
                viewState.isPanning = false;
                viewport.classList.remove('dragging');
            }
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !spacePressed) {
                e.preventDefault();
                spacePressed = true;
                viewport.classList.add('space-mode');
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                spacePressed = false;
                viewport.classList.remove('space-mode');
                viewState.isPanning = false;
                viewport.classList.remove('dragging');
            }
        });
        
        viewport.addEventListener('mousedown', (e) => {
            if (spacePressed && e.button === 0 && !minimapDragging) {
                e.preventDefault();
                viewState.isPanning = true;
                viewState.startX = e.clientX - viewState.x;
                viewState.startY = e.clientY - viewState.y;
                viewport.classList.add('dragging');
            }
        });
        
        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const delta = -e.deltaY * 0.002;
            const newScale = Math.min(Math.max(0.1, viewState.scale * (1 + delta)), 5);
            
            const rect = viewport.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const beforeX = (mouseX - viewState.x) / viewState.scale;
            const beforeY = (mouseY - viewState.y) / viewState.scale;
            
            viewState.scale = newScale;
            
            viewState.x = mouseX - beforeX * viewState.scale;
            viewState.y = mouseY - beforeY * viewState.scale;
            
            updateTransform();
            updateZoomIndicator();
            updateMinimapViewport();
        }, { passive: false });
        
        function updateTransform() {
            content.style.transform = \`translate(\${viewState.x}px, \${viewState.y}px) scale(\${viewState.scale})\`;
        }
        
        function updateZoomIndicator() {
            zoomIndicator.textContent = Math.round(viewState.scale * 100) + '%';
        }
        
        window.addEventListener('load', () => {
            initMinimap();
            updateTransform();
        });
    <\/script>
</body>
</html>`;

    return html;
}

function generateNodeHTML(node, offsetX, offsetY) {
    const x = node.x - offsetX;
    const y = node.y - offsetY;
    const w = node.width || 250;
    const h = node.height || 100;

    let classes = ['canvas-node'];
    let styles = `left:${x}px;top:${y}px;width:${w}px;height:${h}px;white-space:pre-wrap;word-wrap:break-word;`;
        
    if (node.color) {
        if (node.color.startsWith('#')) {
            const rgba = hexToRgba(node.color, 0.08);
            const rgbaBorder = hexToRgba(node.color, 0.2);
            styles += `background:${rgba};border-color:${rgbaBorder};`;
        } else {
            const colorNum = node.color.replace('color-', '');
            classes.push('color-' + colorNum);
        }
    }

    if (node.styleAttributes) {
        if (node.styleAttributes.textAlign) {
            classes.push('text-align-' + node.styleAttributes.textAlign);
        }
        if (node.styleAttributes.shape) {
            classes.push('shape-' + node.styleAttributes.shape);
        }
        if (node.styleAttributes.border === 'invisible') {
            classes.push('border-invisible');
        }
    }

    let content = '';
    if (node.type === 'text') {
        classes.push('text');
        // Âú®ÂØºÂá∫Êó∂‰øùÁïôÂéüÂßãÊñáÊú¨ÔºåÁî±ÂÆ¢Êà∑Á´Ø JS Ê∏≤Êüì
        content = escapeHtml(node.text || '');
    } else if (node.type === 'file') {
        const filePath = node.file || '';
        const isImage = /\.(jpg|jpeg|png|gif|webp|svg|bmp|tiff)$/i.test(filePath);
        
        if (isImage) {
            classes.push('image');
            // ÊèêÂèñÊñá‰ª∂Âêç
            const filename = filePath.split('/').pop().split('\\').pop();
            // ÁîüÊàêÁõ∏ÂØπË∑ØÂæÑÔºöÂÅáËÆæÂõæÁâáÂú® ./images Êñá‰ª∂Â§π‰∏≠
            const imagePath = `./images/${filename}`;
            
            content = `<img src="${imagePath}" alt="${escapeHtml(filename)}" style="width:100%;height:100%;object-fit:contain;" onerror="this.style.display='none';this.parentElement.innerHTML='<div class=\\'missing-image-icon\\'>üñºÔ∏è</div><div class=\\'missing-image-text\\'>${escapeHtml(filename)}</div>'">`;
        } else {
            classes.push('file');
            const fileName = filePath.split('/').pop() || 'file';
            content = `<div class="file-name">üìÑ ${escapeHtml(fileName)}</div>`;
        }
    } else if (node.type === 'group') {
        classes.push('group');
        if (node.label) {
            content = `<div class="group-label">${escapeHtml(node.label)}</div>`;
        }
    }

    return `        <div class="${classes.join(' ')}" style="${styles}">${content}</div>\n`;
}

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }

        function downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function notify(message, type = 'info') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `show ${type}`;
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
    </script>
</body>
</html>